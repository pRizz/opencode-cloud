---
phase: 02-docker-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/core/src/docker/mod.rs
  - packages/core/src/docker/image.rs
  - packages/core/src/docker/progress.rs
autonomous: true

must_haves:
  truths:
    - "User sees real-time progress when pulling Docker image"
    - "User sees real-time progress when building Docker image"
    - "Pull automatically falls back from Docker Hub to GHCR on failure"
  artifacts:
    - path: "packages/core/src/docker/image.rs"
      provides: "Image build and pull operations"
      min_lines: 100
      exports: ["build_image", "pull_image", "image_exists"]
    - path: "packages/core/src/docker/progress.rs"
      provides: "Progress reporting utilities with indicatif"
      min_lines: 50
      contains: "MultiProgress"
  key_links:
    - from: "packages/core/src/docker/image.rs"
      to: "packages/core/src/docker/progress.rs"
      via: "ProgressReporter usage"
      pattern: "ProgressReporter"
    - from: "packages/core/src/docker/image.rs"
      to: "bollard create_image"
      via: "docker.create_image"
      pattern: "create_image"
    - from: "packages/core/src/docker/image.rs"
      to: "bollard build_image"
      via: "docker.build_image"
      pattern: "build_image"
---

<objective>
Implement Docker image build and pull operations with progress feedback.

Purpose: Enable the CLI to build the opencode image from the embedded Dockerfile or pull it from registries with real-time progress indication showing layer-by-layer download status.

Output: Image operations module with streaming progress bars for build and pull operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-docker-integration/02-CONTEXT.md
@.planning/phases/02-docker-integration/02-RESEARCH.md

# Prior plan artifacts
@packages/core/src/docker/mod.rs
@packages/core/src/docker/client.rs
@packages/core/src/docker/error.rs
@packages/core/src/docker/dockerfile.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progress reporting utilities</name>
  <files>
    packages/core/src/docker/progress.rs
    packages/core/src/docker/mod.rs
  </files>
  <action>
Create packages/core/src/docker/progress.rs with indicatif-based progress reporting:

```rust
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};
use std::collections::HashMap;

/// Progress reporter for Docker operations
pub struct ProgressReporter {
    multi: MultiProgress,
    bars: HashMap<String, ProgressBar>,
}

impl ProgressReporter {
    pub fn new() -> Self

    /// Create a spinner for indeterminate progress (e.g., build steps)
    pub fn add_spinner(&mut self, id: &str, message: &str) -> &ProgressBar

    /// Create a progress bar for determinate progress (e.g., layer download)
    /// total is in bytes
    pub fn add_bar(&mut self, id: &str, total: u64) -> &ProgressBar

    /// Update progress for a layer (used during image pull)
    /// current/total in bytes, status is the Docker status message
    pub fn update_layer(&mut self, layer_id: &str, current: u64, total: u64, status: &str)

    /// Update spinner message (used during build)
    pub fn update_spinner(&mut self, id: &str, message: &str)

    /// Mark a layer/step as complete
    pub fn finish(&mut self, id: &str, message: &str)

    /// Mark all progress as complete
    pub fn finish_all(&self, message: &str)

    /// Mark all progress as failed
    pub fn abandon_all(&self, message: &str)
}
```

Progress bar style for layers:
- Template: "{spinner:.green} [{bar:40.cyan/blue}] {bytes}/{total_bytes} ({eta}) {msg}"
- Tick: 100ms

Spinner style for build steps:
- Template: "{spinner:.green} {msg}"
- Spinner chars: standard dots

Update packages/core/src/docker/mod.rs to declare and export progress module.
  </action>
  <verify>
cargo check -p opencode-cloud-core
  </verify>
  <done>
Progress reporter created with support for multi-layer download tracking and build step spinners.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement image build operation</name>
  <files>packages/core/src/docker/image.rs</files>
  <action>
Create packages/core/src/docker/image.rs with image build functionality:

```rust
use crate::docker::{DockerClient, DockerError, DOCKERFILE, IMAGE_NAME_GHCR, IMAGE_TAG_DEFAULT};
use crate::docker::progress::ProgressReporter;
use bollard::query_parameters::BuildImageOptionsBuilder;
use futures_util::stream::TryStreamExt;
use tar::Builder as TarBuilder;
use flate2::write::GzEncoder;
use flate2::Compression;

/// Check if an image exists locally
pub async fn image_exists(client: &DockerClient, image: &str, tag: &str) -> Result<bool, DockerError>

/// Build the opencode image from embedded Dockerfile
/// Shows real-time build progress with streaming output
pub async fn build_image(
    client: &DockerClient,
    tag: Option<&str>,  // defaults to IMAGE_TAG_DEFAULT
    progress: &mut ProgressReporter,
) -> Result<String, DockerError>  // Returns full image:tag
```

Build implementation:
1. Create tar archive containing Dockerfile:
   - Create tar header with path "Dockerfile"
   - Append DOCKERFILE content
   - Compress with gzip

2. Call docker.build_image with BuildImageOptionsBuilder:
   - t: "{IMAGE_NAME_GHCR}:{tag}"
   - dockerfile: "Dockerfile"
   - rm: true (remove intermediate containers)

3. Stream build output:
   - For each BuildInfo in stream:
     - If stream field present: update spinner with message
     - If error field present: return DockerError::Build
     - If aux field present (image ID): capture for return

4. On completion: finish progress with "Build complete: {image_id}"

Error handling:
- Build context creation failure: "Failed to create build context: {error}"
- Docker daemon error during build: "Build failed: {docker_error}"
- Timeout: Use client with 600s timeout for builds
  </action>
  <verify>
cargo check -p opencode-cloud-core
  </verify>
  <done>
Image build function implemented with streaming progress output.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement image pull with registry fallback</name>
  <files>packages/core/src/docker/image.rs</files>
  <action>
Add image pull functionality to packages/core/src/docker/image.rs:

```rust
use bollard::image::CreateImageOptions;
use tokio_retry::Retry;
use tokio_retry::strategy::{ExponentialBackoff, jitter};

/// Pull the opencode image from registry with automatic fallback
/// Tries Docker Hub first, falls back to GHCR on failure
pub async fn pull_image(
    client: &DockerClient,
    tag: Option<&str>,  // defaults to IMAGE_TAG_DEFAULT
    progress: &mut ProgressReporter,
) -> Result<String, DockerError>  // Returns full image:tag

/// Pull from a specific registry (internal helper)
async fn pull_from_registry(
    client: &DockerClient,
    image: &str,
    tag: &str,
    progress: &mut ProgressReporter,
) -> Result<(), DockerError>
```

Pull implementation:
1. First attempt: pull from IMAGE_NAME_DOCKERHUB
2. On failure: log warning, attempt IMAGE_NAME_GHCR
3. On both fail: return error with both failures noted

For each registry pull:
1. Call docker.create_image with CreateImageOptions:
   - from_image: image name
   - tag: tag

2. Stream CreateImageInfo:
   - Track layers by id field
   - For each layer update:
     - If progressDetail has current/total: update_layer progress bar
     - If status is "Pull complete": finish that layer
     - If status is "Already exists": skip/finish immediately
   - Handle no id (overall status messages): update main spinner

3. Retry logic: ExponentialBackoff starting at 1s, max 3 attempts per registry

Progress display during pull:
- Show one progress bar per layer being downloaded
- Layers complete immediately when "Already exists"
- Final message: "Pull complete: {image}:{tag}"
  </action>
  <verify>
cargo check -p opencode-cloud-core && cargo build -p opencode-cloud-core
  </verify>
  <done>
Image pull with multi-layer progress bars and automatic DockerHub-to-GHCR fallback.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p opencode-cloud-core` passes
2. `cargo build -p opencode-cloud-core` succeeds
3. image.rs exports build_image, pull_image, image_exists
4. progress.rs exports ProgressReporter
5. Build uses embedded DOCKERFILE constant
6. Pull tries Docker Hub first, then GHCR
</verification>

<success_criteria>
- Image build creates tar context from embedded Dockerfile
- Build streams progress with real-time output
- Image pull shows per-layer progress bars
- Pull falls back from Docker Hub to GHCR on failure
- Retry logic handles transient network errors
- Progress bars are visually clear and informative
</success_criteria>

<output>
After completion, create `.planning/phases/02-docker-integration/02-02-SUMMARY.md`
</output>
