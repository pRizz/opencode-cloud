---
phase: 02-docker-integration
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - packages/core/src/docker/mod.rs
  - packages/core/src/docker/volume.rs
  - packages/core/src/docker/container.rs
autonomous: true

must_haves:
  truths:
    - "Three named Docker volumes exist for persistence (session, projects, config)"
    - "Container mounts all three volumes at correct paths"
    - "Container can be started, stopped, and removed programmatically"
    - "Session history persists across container restarts"
  artifacts:
    - path: "packages/core/src/docker/volume.rs"
      provides: "Volume creation and management"
      min_lines: 40
      exports: ["ensure_volumes_exist", "VOLUME_NAMES"]
    - path: "packages/core/src/docker/container.rs"
      provides: "Container lifecycle operations"
      min_lines: 80
      exports: ["create_container", "start_container", "stop_container", "remove_container"]
  key_links:
    - from: "packages/core/src/docker/container.rs"
      to: "packages/core/src/docker/volume.rs"
      via: "Volume mounts in container config"
      pattern: "VOLUME_"
    - from: "packages/core/src/docker/container.rs"
      to: "bollard container operations"
      via: "create_container, start_container, stop_container"
      pattern: "\\.(create|start|stop|remove)_container"
---

<objective>
Implement volume persistence and container lifecycle management.

Purpose: Enable the CLI to create containers with persistent storage for session history, project files, and configuration, and to manage the container lifecycle (create, start, stop, remove).

Output: Volume and container modules providing complete Docker lifecycle management with data persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-docker-integration/02-CONTEXT.md
@.planning/phases/02-docker-integration/02-RESEARCH.md

# Prior plan artifacts
@packages/core/src/docker/mod.rs
@packages/core/src/docker/client.rs
@packages/core/src/docker/image.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement volume management</name>
  <files>
    packages/core/src/docker/volume.rs
    packages/core/src/docker/mod.rs
  </files>
  <action>
Create packages/core/src/docker/volume.rs:

```rust
use crate::docker::{DockerClient, DockerError};
use bollard::volume::CreateVolumeOptions;

/// Volume names for persistent storage
pub const VOLUME_SESSION: &str = "opencode-cloud-session";
pub const VOLUME_PROJECTS: &str = "opencode-cloud-projects";
pub const VOLUME_CONFIG: &str = "opencode-cloud-config";

/// All volume names as array for iteration
pub const VOLUME_NAMES: [&str; 3] = [VOLUME_SESSION, VOLUME_PROJECTS, VOLUME_CONFIG];

/// Mount points inside the container
pub const MOUNT_SESSION: &str = "/home/opencode/.opencode";
pub const MOUNT_PROJECTS: &str = "/workspace";
pub const MOUNT_CONFIG: &str = "/home/opencode/.config";

/// Ensure all required volumes exist
/// Creates volumes if they don't exist; idempotent
pub async fn ensure_volumes_exist(client: &DockerClient) -> Result<(), DockerError>

/// Check if a specific volume exists
pub async fn volume_exists(client: &DockerClient, name: &str) -> Result<bool, DockerError>

/// Remove a volume (used during uninstall)
/// Returns error if volume is in use
pub async fn remove_volume(client: &DockerClient, name: &str) -> Result<(), DockerError>

/// Remove all opencode-cloud volumes
pub async fn remove_all_volumes(client: &DockerClient) -> Result<(), DockerError>
```

Volume creation uses CreateVolumeOptions with default local driver.
Bollard's create_volume is idempotent - returns existing volume if it exists.

Update packages/core/src/docker/mod.rs to declare and export volume module.
  </action>
  <verify>
cargo check -p opencode-cloud-core
  </verify>
  <done>
Volume management functions created with named volume constants and mount points defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement container lifecycle operations</name>
  <files>packages/core/src/docker/container.rs</files>
  <action>
Create packages/core/src/docker/container.rs:

```rust
use crate::docker::{DockerClient, DockerError};
use crate::docker::volume::{VOLUME_SESSION, VOLUME_PROJECTS, VOLUME_CONFIG, MOUNT_SESSION, MOUNT_PROJECTS, MOUNT_CONFIG};
use crate::docker::dockerfile::{IMAGE_NAME_GHCR, IMAGE_TAG_DEFAULT};
use bollard::container::{Config, CreateContainerOptions, StartContainerOptions, StopContainerOptions, RemoveContainerOptions};
use bollard::service::{Mount, MountTypeEnum, HostConfig, PortBinding, RestartPolicy, RestartPolicyNameEnum};
use std::collections::HashMap;

/// Default container name
pub const CONTAINER_NAME: &str = "opencode-cloud";

/// Default port for opencode web UI
pub const DEFAULT_PORT: u16 = 3000;

/// Create the opencode container with volume mounts
/// Does not start the container
pub async fn create_container(
    client: &DockerClient,
    name: Option<&str>,  // defaults to CONTAINER_NAME
    image: Option<&str>,  // defaults to IMAGE_NAME_GHCR:IMAGE_TAG_DEFAULT
    host_port: Option<u16>,  // defaults to DEFAULT_PORT
    env_vars: Option<Vec<String>>,  // additional environment variables
) -> Result<String, DockerError>  // Returns container ID

/// Start an existing container
pub async fn start_container(client: &DockerClient, name: &str) -> Result<(), DockerError>

/// Stop a running container with graceful shutdown
/// timeout_secs: seconds to wait before force kill (default: 10)
pub async fn stop_container(client: &DockerClient, name: &str, timeout_secs: Option<i64>) -> Result<(), DockerError>

/// Remove a container
/// force: remove even if running
pub async fn remove_container(client: &DockerClient, name: &str, force: bool) -> Result<(), DockerError>

/// Check if container exists
pub async fn container_exists(client: &DockerClient, name: &str) -> Result<bool, DockerError>

/// Check if container is running
pub async fn container_is_running(client: &DockerClient, name: &str) -> Result<bool, DockerError>

/// Get container state (running, stopped, etc.)
pub async fn container_state(client: &DockerClient, name: &str) -> Result<String, DockerError>
```

Container creation configuration:
1. Image: "{IMAGE_NAME_GHCR}:{IMAGE_TAG_DEFAULT}" (or provided image)
2. Hostname: "opencode-cloud"
3. Working directory: "/workspace"
4. Exposed port: 3000/tcp
5. Port binding: host_port -> 3000

Volume mounts (all as named volumes, not bind mounts):
```rust
let mounts = vec![
    Mount {
        target: Some(MOUNT_SESSION.to_string()),
        source: Some(VOLUME_SESSION.to_string()),
        typ: Some(MountTypeEnum::VOLUME),
        read_only: Some(false),
        ..Default::default()
    },
    Mount {
        target: Some(MOUNT_PROJECTS.to_string()),
        source: Some(VOLUME_PROJECTS.to_string()),
        typ: Some(MountTypeEnum::VOLUME),
        read_only: Some(false),
        ..Default::default()
    },
    Mount {
        target: Some(MOUNT_CONFIG.to_string()),
        source: Some(VOLUME_CONFIG.to_string()),
        typ: Some(MountTypeEnum::VOLUME),
        read_only: Some(false),
        ..Default::default()
    },
];
```

Host config:
- Mounts: volume mounts array
- Port bindings: {"3000/tcp": [PortBinding { host_ip: Some("127.0.0.1"), host_port: Some(host_port.to_string()) }]}
- Restart policy: None (managed by our CLI, not Docker)
- Auto remove: false (we manage lifecycle)

Error handling:
- Container already exists: return descriptive error
- Image not found: "Image not found. Run 'opencode-cloud pull' first."
- Port in use: "Port {port} is already in use."
  </action>
  <verify>
cargo check -p opencode-cloud-core
  </verify>
  <done>
Container lifecycle operations implemented with volume mounts and port binding.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up module exports and add integration convenience functions</name>
  <files>
    packages/core/src/docker/mod.rs
    packages/core/src/lib.rs
  </files>
  <action>
Update packages/core/src/docker/mod.rs:
- Declare container module: pub mod container;
- Add comprehensive re-exports for public API:

```rust
// Module declarations
pub mod client;
pub mod container;
pub mod dockerfile;
pub mod error;
pub mod image;
pub mod progress;
pub mod volume;

// Re-exports for convenient access
pub use client::DockerClient;
pub use error::DockerError;
pub use dockerfile::{DOCKERFILE, IMAGE_NAME_GHCR, IMAGE_NAME_DOCKERHUB, IMAGE_TAG_DEFAULT};
pub use image::{build_image, pull_image, image_exists};
pub use volume::{ensure_volumes_exist, VOLUME_NAMES, VOLUME_SESSION, VOLUME_PROJECTS, VOLUME_CONFIG};
pub use container::{
    create_container, start_container, stop_container, remove_container,
    container_exists, container_is_running, container_state,
    CONTAINER_NAME, DEFAULT_PORT,
};
pub use progress::ProgressReporter;
```

Add a convenience function for common workflow (setup + start):

```rust
/// Full setup: ensure volumes exist, create container if needed, start it
/// Returns the container ID
pub async fn setup_and_start(
    client: &DockerClient,
    host_port: Option<u16>,
    env_vars: Option<Vec<String>>,
) -> Result<String, DockerError> {
    // Ensure volumes exist
    volume::ensure_volumes_exist(client).await?;

    // Create container if it doesn't exist
    let container_id = if !container::container_exists(client, container::CONTAINER_NAME).await? {
        container::create_container(client, None, None, host_port, env_vars).await?
    } else {
        // Get existing container ID
        // ... implementation
    };

    // Start if not running
    if !container::container_is_running(client, container::CONTAINER_NAME).await? {
        container::start_container(client, container::CONTAINER_NAME).await?;
    }

    Ok(container_id)
}
```

Update packages/core/src/lib.rs:
- Ensure docker module is public
- Add selective re-exports for most common types:

```rust
// Add to existing re-exports
pub use docker::{DockerClient, DockerError, CONTAINER_NAME, DEFAULT_PORT};
```
  </action>
  <verify>
cargo check -p opencode-cloud-core && cargo build -p opencode-cloud-core && cargo test -p opencode-cloud-core
  </verify>
  <done>
Docker module fully wired with convenient re-exports and setup_and_start convenience function.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p opencode-cloud-core` passes
2. `cargo build -p opencode-cloud-core` succeeds
3. `cargo test -p opencode-cloud-core` passes (compilation tests)
4. Volume constants match expected paths for opencode
5. Container config includes all three volume mounts
6. Port binding defaults to localhost (127.0.0.1)
7. Module exports are accessible from lib.rs
</verification>

<success_criteria>
- Volume management ensures three named volumes exist
- Container creation mounts all volumes at correct paths:
  - opencode-cloud-session -> /home/opencode/.opencode (session history)
  - opencode-cloud-projects -> /workspace (project files)
  - opencode-cloud-config -> /home/opencode/.config (opencode config)
- Container lifecycle (create/start/stop/remove) works programmatically
- Default port binding is 127.0.0.1:3000 (localhost only for security)
- Module exports provide clean public API
</success_criteria>

<output>
After completion, create `.planning/phases/02-docker-integration/02-03-SUMMARY.md`
</output>
