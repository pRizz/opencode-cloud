---
phase: 18-cli-sync-strategy
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - CONTRIBUTING.md
  - packages/cli-rust/README.md
autonomous: true

must_haves:
  truths:
    - "CONTRIBUTING.md documents how to add new CLI commands"
    - "Documentation explains Rust CLI is source of truth"
    - "Process makes clear no Node changes needed for new commands"
  artifacts:
    - path: "CONTRIBUTING.md"
      provides: "Guide for adding new commands, CLI architecture explanation"
      contains: "Adding New Commands"
    - path: "packages/cli-rust/README.md"
      provides: "CLI-specific documentation with command list"
      contains: "source of truth"
  key_links:
    - from: "CONTRIBUTING.md"
      to: "packages/cli-rust"
      via: "Documentation reference"
      pattern: "packages/cli-rust"
---

<objective>
Document the CLI sync strategy, command addition process, and architecture in CONTRIBUTING.md and package READMEs.

Purpose: Ensures future contributors understand that Rust CLI is the source of truth and Node CLI automatically delegates. Provides clear steps for adding new commands.

Output: Updated CONTRIBUTING.md with CLI architecture section and command addition guide, updated packages/cli-rust/README.md with authoritative status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-cli-sync-strategy/18-CONTEXT.md
@.planning/phases/18-cli-sync-strategy/18-RESEARCH.md
@CONTRIBUTING.md (if exists)
@packages/cli-rust/README.md (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create or update CONTRIBUTING.md with CLI architecture</name>
  <files>CONTRIBUTING.md</files>
  <action>
Create CONTRIBUTING.md (or update if exists) with a section on CLI architecture:

```markdown
# Contributing to opencode-cloud

## Getting Started

1. Clone the repository
2. Install dependencies: `pnpm install`
3. Build everything: `just build`
4. Run tests: `just test`

## CLI Architecture

This project has two CLI entry points:

- **packages/cli-rust** - The Rust CLI (source of truth)
- **packages/cli-node** - Node.js wrapper (delegates to Rust binary)

### How It Works

The Rust CLI (`packages/cli-rust`) contains all command implementations using clap for argument parsing. The Node CLI (`packages/cli-node`) is a thin wrapper that:

1. Spawns the Rust binary with all arguments passed through
2. Uses `stdio: 'inherit'` for transparent I/O (colors, TTY detection work)
3. Exits with the same code as the Rust binary

This means:
- **Rust CLI is the single source of truth** for all commands
- **Node CLI requires no updates** when adding new commands
- **CI parity tests** verify both CLIs support all commands

### Adding New Commands

To add a new CLI command:

1. **Create the command in Rust:**
   - Add a new file in `packages/cli-rust/src/commands/`
   - Register it in `packages/cli-rust/src/commands/mod.rs`
   - Add the subcommand to the `Commands` enum in `packages/cli-rust/src/lib.rs`

2. **That's it!** No changes needed in packages/cli-node.

The Node CLI automatically delegates all arguments to the Rust binary, so new commands work immediately. CI parity tests will verify the command is accessible.

### Example: Adding a "shell" Command

```rust
// packages/cli-rust/src/commands/shell.rs
use clap::Args;

#[derive(Args)]
pub struct ShellArgs {
    /// Command to run (default: interactive shell)
    pub command: Option<String>,
}

pub async fn cmd_shell(args: &ShellArgs) -> anyhow::Result<()> {
    // Implementation...
    Ok(())
}
```

```rust
// packages/cli-rust/src/commands/mod.rs
mod shell;
pub use shell::{ShellArgs, cmd_shell};
```

```rust
// packages/cli-rust/src/lib.rs
#[derive(Subcommand)]
enum Commands {
    // ... existing commands ...
    Shell(commands::ShellArgs),
}
```

### Testing CLI Commands

- **Rust tests:** Add tests in `packages/cli-rust/src/commands/` alongside implementation
- **Parity tests:** Run `pnpm -C packages/cli-node test` to verify Node CLI can invoke the command
- **Manual testing:**
  - Rust: `cargo run -p opencode-cloud -- <command>`
  - Node: `node packages/cli-node/dist/index.js <command>` (requires binary in bin/)

## Pre-Commit Checklist

Before committing, ensure:

1. `just fmt` - Code is formatted
2. `just lint` - No clippy warnings
3. `just test` - All tests pass
4. `just build` - Release build succeeds

## Code Style

See the project's CLAUDE.md for detailed coding conventions.
```

Adjust the content based on whether CONTRIBUTING.md already exists (merge with existing content).
  </action>
  <verify>
`cat CONTRIBUTING.md` shows CLI Architecture and Adding New Commands sections.
  </verify>
  <done>
CONTRIBUTING.md explains CLI architecture, passthrough model, and step-by-step command addition process.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update packages/cli-rust/README.md</name>
  <files>packages/cli-rust/README.md</files>
  <action>
Create or update packages/cli-rust/README.md to document its role as source of truth:

```markdown
# opencode-cloud Rust CLI

This is the **source of truth** for all opencode-cloud CLI commands.

## Architecture

The Rust CLI implements all commands using [clap](https://docs.rs/clap). The Node.js CLI (`packages/cli-node`) delegates to this binary - it does not duplicate any command logic.

When adding new commands, add them here. The Node CLI will automatically support them through passthrough delegation.

## Building

```bash
# Debug build
cargo build -p opencode-cloud

# Release build
cargo build --release -p opencode-cloud

# Run directly
cargo run -p opencode-cloud -- --help
```

## Project Structure

```
src/
├── lib.rs          # CLI entry point, clap definitions
├── commands/       # Command implementations
│   ├── mod.rs      # Command exports
│   ├── start.rs    # occ start
│   ├── stop.rs     # occ stop
│   └── ...         # Other commands
├── output/         # Output formatting utilities
└── wizard/         # Setup wizard implementation
```

## Adding Commands

See CONTRIBUTING.md in the repository root for detailed instructions.

Quick steps:
1. Create `src/commands/yourcommand.rs`
2. Add to `src/commands/mod.rs`
3. Register in `src/lib.rs` Commands enum

No changes needed in packages/cli-node - it delegates automatically.

## Testing

```bash
# Run all tests
cargo test -p opencode-cloud

# Run specific test
cargo test -p opencode-cloud -- test_name
```
```
  </action>
  <verify>
`cat packages/cli-rust/README.md` shows "source of truth" and architecture explanation.
  </verify>
  <done>
packages/cli-rust/README.md documents authoritative role, project structure, and command addition process.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. CONTRIBUTING.md exists with "CLI Architecture" and "Adding New Commands" sections
2. packages/cli-rust/README.md exists with "source of truth" language
3. Documentation is accurate and actionable for new contributors
</verification>

<success_criteria>
- Clear documentation that Rust CLI is source of truth
- Step-by-step guide for adding new commands
- Explicit statement that Node CLI needs no changes for new commands
- Links between documents for discoverability
</success_criteria>

<output>
After completion, create `.planning/phases/18-cli-sync-strategy/18-03-SUMMARY.md`
</output>
