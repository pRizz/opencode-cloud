---
phase: 18-cli-sync-strategy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/cli-node/src/index.ts
  - packages/cli-node/package.json
  - packages/cli-node/tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Node CLI delegates all arguments to Rust binary"
    - "Node CLI exits with same code as Rust binary"
    - "Node CLI inherits stdio (colors, TTY detection work)"
    - "Node CLI shows helpful error when binary missing"
  artifacts:
    - path: "packages/cli-node/src/index.ts"
      provides: "Passthrough wrapper using spawn with stdio: inherit"
      min_lines: 30
  key_links:
    - from: "packages/cli-node/src/index.ts"
      to: "Rust binary"
      via: "child_process.spawn"
      pattern: "spawn\\(.*stdio.*inherit"
---

<objective>
Convert the deprecated Node CLI stub into a transparent passthrough wrapper that spawns the Rust binary.

Purpose: The Node CLI currently just prints a deprecation message and exits. This plan transforms it into a thin wrapper that delegates ALL commands to the Rust binary, enabling npm users to use the CLI without installing Rust.

Output: A working Node CLI that spawns the Rust binary and passes through all arguments, with proper exit code handling and helpful error messages when the binary is missing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-cli-sync-strategy/18-CONTEXT.md
@.planning/phases/18-cli-sync-strategy/18-RESEARCH.md
@packages/cli-node/src/index.ts
@packages/cli-node/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement passthrough wrapper</name>
  <files>packages/cli-node/src/index.ts</files>
  <action>
Replace the entire deprecated stub with a passthrough implementation:

1. Import spawn from 'child_process', fileURLToPath from 'url', dirname/join from 'path'
2. Resolve binary path relative to the script:
   - Use `import.meta.url` to get current file location
   - Binary should be at `../bin/occ` relative to dist/index.js
   - For now, expect binary to be pre-placed in bin/ directory
3. Spawn the binary with:
   - Arguments: `process.argv.slice(2)` (pass all args after 'node script.js')
   - Options: `{ stdio: 'inherit' }` for transparent passthrough
4. Handle 'close' event: `process.exit(code ?? 1)`
5. Handle 'error' event (binary not found):
   - Print helpful error message suggesting cargo install
   - Include platform info (process.platform, process.arch)
   - Exit with code 1

Keep the shebang `#!/usr/bin/env node` at the top.

Do NOT add any command parsing or interception - this is pure passthrough.
  </action>
  <verify>
Run `pnpm -C packages/cli-node build` to verify TypeScript compiles.
  </verify>
  <done>
packages/cli-node/src/index.ts contains spawn-based passthrough wrapper with stdio: inherit and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update package.json for passthrough model</name>
  <files>packages/cli-node/package.json</files>
  <action>
Update package.json to reflect the new passthrough model:

1. Remove the dependency on "@opencode-cloud/core" - the Node CLI no longer uses NAPI bindings, it just spawns the Rust binary
2. Keep the bin entries as-is (opencode-cloud and occ both point to ./dist/index.js)
3. Keep devDependencies (typescript, @types/node) for building
4. Add a "files" array to include the bin directory when publishing:
   ```json
   "files": [
     "dist",
     "bin"
   ]
   ```
5. Update description to clarify it's a wrapper:
   ```json
   "description": "Node.js wrapper for opencode-cloud CLI (delegates to Rust binary)"
   ```

Do NOT add optionalDependencies yet - that's for Phase 22 (prebuilt binary distribution). For now, users need to either:
- Have the binary pre-placed in bin/ (for development/CI)
- Install via cargo (for end users)
  </action>
  <verify>
Run `pnpm install` to verify dependencies resolve.
  </verify>
  <done>
package.json updated: @opencode-cloud/core removed, files array added, description updated.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create bin directory placeholder and document binary placement</name>
  <files>packages/cli-node/bin/.gitkeep, packages/cli-node/README.md</files>
  <action>
1. Create `packages/cli-node/bin/.gitkeep` to ensure the bin directory exists in git (will hold platform binaries later)

2. Create or update `packages/cli-node/README.md` with:
   - Title: "opencode-cloud Node.js CLI"
   - Brief explanation that this is a wrapper around the Rust binary
   - Section "Binary Placement" explaining:
     - Development: Copy `target/release/occ` to `packages/cli-node/bin/occ`
     - CI: Workflow copies built binaries to bin/ before testing
     - Users: Currently need to install via `cargo install opencode-cloud`
   - Section "How it works":
     - Node CLI spawns Rust binary with all arguments
     - stdio: inherit passes through colors, TTY, signals
     - Exit code propagated from Rust binary
   - Note that prebuilt binary distribution (optionalDependencies) is planned for Phase 22
  </action>
  <verify>
`ls packages/cli-node/bin/` shows .gitkeep exists.
`cat packages/cli-node/README.md` shows documentation.
  </verify>
  <done>
bin/.gitkeep exists, README.md documents the passthrough model and binary placement.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm -C packages/cli-node build` succeeds
2. Code review: index.ts uses spawn with stdio: inherit
3. package.json no longer has @opencode-cloud/core dependency
4. bin/.gitkeep exists
5. README.md documents the passthrough model
</verification>

<success_criteria>
- Node CLI source code is a pure passthrough wrapper (~30-40 lines)
- No NAPI bindings dependency (removed @opencode-cloud/core)
- Error handling provides helpful message when binary missing
- Documentation explains binary placement for dev/CI/users
</success_criteria>

<output>
After completion, create `.planning/phases/18-cli-sync-strategy/18-01-SUMMARY.md`
</output>
