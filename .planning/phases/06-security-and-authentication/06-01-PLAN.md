---
phase: 06-security-and-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/config/schema.rs
  - packages/core/src/docker/exec.rs
  - packages/core/src/docker/users.rs
  - packages/core/src/docker/mod.rs
  - packages/core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Config schema accepts bind_address, trust_proxy, allow_unauthenticated_network, rate_limit_*, users fields"
    - "Docker exec wrapper can run commands in running container and capture output"
    - "User management module can create users with home directories via useradd"
    - "User management module can set passwords via chpasswd (non-interactive)"
  artifacts:
    - path: "packages/core/src/config/schema.rs"
      provides: "Extended Config struct with security fields"
      contains: "bind_address"
    - path: "packages/core/src/docker/exec.rs"
      provides: "Container exec wrapper using bollard"
      exports: ["exec_command", "exec_command_with_stdin"]
    - path: "packages/core/src/docker/users.rs"
      provides: "User management operations"
      exports: ["create_user", "set_user_password", "user_exists", "lock_user", "unlock_user", "delete_user", "list_users"]
  key_links:
    - from: "packages/core/src/docker/users.rs"
      to: "packages/core/src/docker/exec.rs"
      via: "exec_command calls"
      pattern: "exec_command.*container"
---

<objective>
Extend config schema with security fields and create Docker exec wrapper for container user management.

Purpose: Foundation for PAM-based authentication - opencode authenticates via PAM, so opencode-cloud must manage system users in the container. This plan creates the core library functions for exec and user operations.

Output: Extended Config struct, exec.rs wrapper, users.rs module with create/password/lock/unlock/delete/list operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-security-and-authentication/06-CONTEXT.md
@.planning/phases/06-security-and-authentication/06-RESEARCH.md
@packages/core/src/config/schema.rs
@packages/core/src/docker/client.rs
@packages/core/src/docker/container.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config schema with security fields</name>
  <files>packages/core/src/config/schema.rs</files>
  <action>
Add security-related fields to the Config struct:

1. `bind_address: String` - Default "127.0.0.1", validates as IPv4/IPv6 address
2. `trust_proxy: bool` - Default false, for load balancer deployments
3. `allow_unauthenticated_network: bool` - Default false, double opt-in for unauthenticated 0.0.0.0
4. `rate_limit_attempts: u32` - Default 5, max auth attempts before rate limiting
5. `rate_limit_window_seconds: u32` - Default 60, rate limit window
6. `users: Vec<String>` - Default empty, list of usernames (NOT passwords) for persistence tracking

Add default functions:
- `default_bind_address() -> String` returns "127.0.0.1"
- `default_rate_limit_attempts() -> u32` returns 5
- `default_rate_limit_window() -> u32` returns 60

Add helper methods to Config impl:
- `is_network_exposed(&self) -> bool` - returns true if bind_address is "0.0.0.0" or "::"
- `is_localhost(&self) -> bool` - returns true if bind_address is "127.0.0.1", "::1", or "localhost"

Add validation function:
- `validate_bind_address(addr: &str) -> Result<std::net::IpAddr, String>` - parses IPv4/IPv6, accepts "localhost" as 127.0.0.1, strips brackets from [::1]

Update Default impl to include new fields.

Add tests for new fields, is_network_exposed, is_localhost, and validate_bind_address.
  </action>
  <verify>`just test` passes, including new tests for security fields</verify>
  <done>Config struct has all security fields with defaults and validation helpers</done>
</task>

<task type="auto">
  <name>Task 2: Create Docker exec wrapper module</name>
  <files>packages/core/src/docker/exec.rs, packages/core/src/docker/mod.rs</files>
  <action>
Create `packages/core/src/docker/exec.rs` with container exec functionality using bollard:

1. `exec_command(client: &DockerClient, container: &str, cmd: Vec<&str>) -> Result<String, DockerError>`
   - Creates exec config with attach_stdout=true, attach_stderr=true
   - Runs via create_exec + start_exec
   - Collects output via StreamExt
   - Returns combined stdout/stderr as String

2. `exec_command_with_stdin(client: &DockerClient, container: &str, cmd: Vec<&str>, stdin_data: &str) -> Result<String, DockerError>`
   - Same as above but with attach_stdin=true
   - Writes stdin_data to input stream
   - Used for chpasswd which reads "user:password" from stdin

3. `exec_command_exit_code(client: &DockerClient, container: &str, cmd: Vec<&str>) -> Result<i64, DockerError>`
   - Like exec_command but returns exit code instead of output
   - Uses inspect_exec to get exit code after completion

Use these bollard imports:
```rust
use bollard::exec::{CreateExecOptions, StartExecResults};
use futures_util::StreamExt;
```

For stdin writing, use the input stream from StartExecResults::Attached.

Update `packages/core/src/docker/mod.rs` to:
- Add `pub mod exec;`
- Re-export: `pub use exec::{exec_command, exec_command_with_stdin, exec_command_exit_code};`

Add unit tests that verify compilation (actual Docker tests would need running container).
  </action>
  <verify>`just test` passes, `just lint` passes</verify>
  <done>exec.rs module exists with exec_command, exec_command_with_stdin, exec_command_exit_code functions</done>
</task>

<task type="auto">
  <name>Task 3: Create user management module</name>
  <files>packages/core/src/docker/users.rs, packages/core/src/docker/mod.rs, packages/core/src/lib.rs</files>
  <action>
Create `packages/core/src/docker/users.rs` with user management operations:

1. `create_user(client: &DockerClient, container: &str, username: &str) -> Result<(), DockerError>`
   - Runs: `useradd -m -s /bin/bash {username}`
   - Creates home directory (-m) and sets shell (-s)
   - Returns error if user already exists (non-zero exit code)

2. `set_user_password(client: &DockerClient, container: &str, username: &str, password: &str) -> Result<(), DockerError>`
   - Uses exec_command_with_stdin with cmd=["chpasswd"]
   - Writes "{username}:{password}\n" to stdin
   - Non-interactive password setting (no TTY needed)
   - IMPORTANT: Password never appears in command arguments (security)

3. `user_exists(client: &DockerClient, container: &str, username: &str) -> Result<bool, DockerError>`
   - Runs: `id -u {username}`
   - Returns true if exit code is 0, false if non-zero

4. `lock_user(client: &DockerClient, container: &str, username: &str) -> Result<(), DockerError>`
   - Runs: `passwd -l {username}`
   - Locks the account (disables password)

5. `unlock_user(client: &DockerClient, container: &str, username: &str) -> Result<(), DockerError>`
   - Runs: `passwd -u {username}`
   - Unlocks the account

6. `delete_user(client: &DockerClient, container: &str, username: &str) -> Result<(), DockerError>`
   - Runs: `userdel -r {username}`
   - Removes user and home directory (-r)

7. `list_users(client: &DockerClient, container: &str) -> Result<Vec<UserInfo>, DockerError>`
   - Runs: `getent passwd | grep '/home/'`
   - Parses output to extract username, uid, home, shell
   - Returns Vec<UserInfo>
   - UserInfo struct: { username: String, uid: u32, home: String, shell: String, locked: bool }
   - To check locked: `passwd -S {username}` returns "L" for locked

Update `packages/core/src/docker/mod.rs`:
- Add `pub mod users;`
- Re-export: `pub use users::{create_user, set_user_password, user_exists, lock_user, unlock_user, delete_user, list_users, UserInfo};`

Update `packages/core/src/lib.rs` if needed to re-export docker::users types.

Add unit tests for UserInfo struct parsing (can test parsing logic without Docker).
  </action>
  <verify>`just test` passes, `just lint` passes, `just fmt` passes</verify>
  <done>users.rs module exists with all user management functions and UserInfo struct</done>
</task>

</tasks>

<verification>
After all tasks:
1. `just fmt` - Code is formatted
2. `just lint` - No clippy warnings
3. `just test` - All tests pass including new ones
4. `just build` - Release build succeeds
5. Verify exports: `grep -r "pub use.*exec_command" packages/core/src/`
6. Verify exports: `grep -r "pub use.*create_user" packages/core/src/`
</verification>

<success_criteria>
- Config struct has bind_address, trust_proxy, allow_unauthenticated_network, rate_limit_*, users fields
- validate_bind_address handles IPv4, IPv6, "localhost", and bracketed [::1]
- is_network_exposed returns true for 0.0.0.0 and ::
- exec.rs provides exec_command and exec_command_with_stdin functions
- users.rs provides create_user, set_user_password, user_exists, lock_user, unlock_user, delete_user, list_users
- All functions use DockerClient and return Result<T, DockerError>
- Password is never passed as command argument (uses stdin via chpasswd)
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-and-authentication/06-01-SUMMARY.md`
</output>
