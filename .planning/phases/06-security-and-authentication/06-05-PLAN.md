---
phase: 06-security-and-authentication
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - packages/cli-rust/src/commands/config/set.rs
  - packages/cli-rust/src/commands/config/show.rs
  - packages/cli-rust/src/commands/config/get.rs
autonomous: true

must_haves:
  truths:
    - "User can set trust_proxy via occ config set trust_proxy"
    - "User can set rate_limit_attempts and rate_limit_window_seconds via config"
    - "User can set allow_unauthenticated_network with confirmation prompt"
    - "Config show displays all security-related settings"
  artifacts:
    - path: "packages/cli-rust/src/commands/config/set.rs"
      provides: "Config set for all security fields"
      contains: "trust_proxy"
    - path: "packages/cli-rust/src/commands/config/show.rs"
      provides: "Config show with security fields"
      contains: "trust_proxy"
  key_links:
    - from: "packages/cli-rust/src/commands/config/set.rs"
      to: "config.trust_proxy"
      via: "Config mutation"
      pattern: "trust_proxy"
---

<objective>
Complete config command support for remaining security fields (trust_proxy, rate_limit_*, allow_unauthenticated_network).

Purpose: Expose all security configuration options via CLI for load balancer integration (trust_proxy), rate limiting customization, and explicit unauthenticated network opt-in.

Output: Full config command support for trust_proxy, rate_limit_attempts, rate_limit_window_seconds, allow_unauthenticated_network with appropriate warnings and validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-security-and-authentication/06-CONTEXT.md
@packages/cli-rust/src/commands/config/set.rs
@packages/cli-rust/src/commands/config/show.rs
@packages/cli-rust/src/commands/config/get.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trust_proxy and rate_limit config set support</name>
  <files>packages/cli-rust/src/commands/config/set.rs</files>
  <action>
Add cases to the config set match statement:

**trust_proxy:**
```rust
"trust_proxy" | "proxy" => {
    let trust = parse_bool(value)?;
    config.trust_proxy = trust;
    if trust {
        println!("{}", style("Trust proxy enabled").cyan());
        println!();
        println!("The service will trust X-Forwarded-* headers from reverse proxies.");
        println!("Only enable this when running behind a trusted load balancer.");
        println!();
        println!("Supported headers:");
        println!("  - X-Forwarded-For (client IP)");
        println!("  - X-Forwarded-Proto (original protocol)");
        println!("  - X-Forwarded-Host (original host)");
    }
}
```

**rate_limit_attempts:**
```rust
"rate_limit_attempts" | "rate_attempts" => {
    let attempts: u32 = value.parse().map_err(|_| {
        anyhow!("Invalid number. Must be a positive integer.")
    })?;
    if attempts == 0 {
        return Err(anyhow!("Rate limit attempts must be at least 1"));
    }
    if attempts > 100 {
        println!("{}", style("Warning: High rate limit (>100) may reduce security").yellow());
    }
    config.rate_limit_attempts = attempts;
}
```

**rate_limit_window_seconds:**
```rust
"rate_limit_window_seconds" | "rate_window" | "rate_limit_window" => {
    let window: u32 = value.parse().map_err(|_| {
        anyhow!("Invalid number. Must be a positive integer.")
    })?;
    if window == 0 {
        return Err(anyhow!("Rate limit window must be at least 1 second"));
    }
    if window < 10 {
        println!("{}", style("Warning: Very short window (<10s) may cause false positives").yellow());
    }
    config.rate_limit_window_seconds = window;
}
```

Reuse the existing `parse_bool` helper function for trust_proxy.
  </action>
  <verify>`occ config set trust_proxy true` works, `occ config set rate_limit_attempts 10` works</verify>
  <done>Config set supports trust_proxy and rate_limit_* fields with validation</done>
</task>

<task type="auto">
  <name>Task 2: Add allow_unauthenticated_network with double confirmation</name>
  <files>packages/cli-rust/src/commands/config/set.rs</files>
  <action>
Add allow_unauthenticated_network case with special handling:

```rust
"allow_unauthenticated_network" | "allow_unauth" | "unauth_network" => {
    let allow = parse_bool(value)?;

    if allow {
        // Double opt-in per CONTEXT.md
        println!();
        println!("{}", style("WARNING: DANGEROUS SECURITY SETTING").red().bold());
        println!();
        println!("You are about to allow unauthenticated network access.");
        println!("This means ANYONE on your network can access the opencode web UI");
        println!("without logging in.");
        println!();
        println!("This is typically only appropriate for:");
        println!("  - Development environments on trusted networks");
        println!("  - Services behind an authenticating reverse proxy");
        println!();

        // First confirmation
        let confirm1 = dialoguer::Confirm::new()
            .with_prompt("Do you understand this risk?")
            .default(false)
            .interact()?;

        if !confirm1 {
            println!("Aborted. Setting not changed.");
            return Ok(());
        }

        // Second confirmation (double opt-in)
        let confirm2 = dialoguer::Confirm::new()
            .with_prompt("Are you SURE you want to enable unauthenticated network access?")
            .default(false)
            .interact()?;

        if !confirm2 {
            println!("Aborted. Setting not changed.");
            return Ok(());
        }

        config.allow_unauthenticated_network = true;
        println!();
        println!("{}", style("Unauthenticated network access enabled.").yellow());
        println!("To disable: occ config set allow_unauthenticated_network false");
    } else {
        config.allow_unauthenticated_network = false;
        println!("{}", style("Unauthenticated network access disabled.").green());
    }
}
```

Note: This requires dialoguer import if not already present.
  </action>
  <verify>`occ config set allow_unauthenticated_network true` shows double confirmation</verify>
  <done>allow_unauthenticated_network requires double Y/N confirmation before enabling</done>
</task>

<task type="auto">
  <name>Task 3: Update config show and get for security fields</name>
  <files>packages/cli-rust/src/commands/config/show.rs, packages/cli-rust/src/commands/config/get.rs</files>
  <action>
**Update show.rs:**

Add security fields to the table output:

```rust
// In the table building section:
table.add_row(vec![
    Cell::new("bind_address"),
    Cell::new(&config.bind_address).fg(
        if config.is_localhost() { Color::Green } else { Color::Yellow }
    ),
]);
table.add_row(vec![
    Cell::new("trust_proxy"),
    Cell::new(if config.trust_proxy { "true" } else { "false" }),
]);
table.add_row(vec![
    Cell::new("allow_unauthenticated_network"),
    Cell::new(if config.allow_unauthenticated_network { "true" } else { "false" }).fg(
        if config.allow_unauthenticated_network { Color::Yellow } else { Color::Reset }
    ),
]);
table.add_row(vec![
    Cell::new("rate_limit_attempts"),
    Cell::new(&config.rate_limit_attempts.to_string()),
]);
table.add_row(vec![
    Cell::new("rate_limit_window_seconds"),
    Cell::new(&config.rate_limit_window_seconds.to_string()),
]);
table.add_row(vec![
    Cell::new("users"),
    Cell::new(if config.users.is_empty() {
        "(none)".to_string()
    } else {
        config.users.join(", ")
    }),
]);
```

Update MaskedConfig to include these fields (users is not sensitive, just display).

**Update get.rs:**

Add cases for all new fields:

```rust
"bind_address" | "bind" | "host" => config.bind_address.clone(),
"trust_proxy" | "proxy" => config.trust_proxy.to_string(),
"allow_unauthenticated_network" | "allow_unauth" | "unauth_network" => {
    config.allow_unauthenticated_network.to_string()
}
"rate_limit_attempts" | "rate_attempts" => config.rate_limit_attempts.to_string(),
"rate_limit_window_seconds" | "rate_window" | "rate_limit_window" => {
    config.rate_limit_window_seconds.to_string()
}
"users" => {
    if config.users.is_empty() {
        "(none)".to_string()
    } else {
        config.users.join(",")
    }
}
```
  </action>
  <verify>`occ config show` displays all security fields, `occ config get trust_proxy` returns value</verify>
  <done>Config show displays all security fields, config get supports all security field names</done>
</task>

</tasks>

<verification>
After all tasks:
1. `just fmt` - Code is formatted
2. `just lint` - No clippy warnings
3. `just test` - All tests pass
4. `just build` - Release build succeeds
5. `occ config show` displays all security fields
6. `occ config set trust_proxy true` shows proxy header info
7. `occ config set allow_unauthenticated_network true` shows double confirmation
8. `occ config get rate_limit_attempts` returns the value
</verification>

<success_criteria>
- occ config set trust_proxy true|false works with informational message
- occ config set rate_limit_attempts N validates positive integer
- occ config set rate_limit_window_seconds N validates positive integer
- occ config set allow_unauthenticated_network true shows double Y/N confirmation
- occ config show displays all security fields with appropriate colors
- occ config get supports all security field names with aliases
- Dangerous settings show warnings (high rate limit, allow unauth network)
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-and-authentication/06-05-SUMMARY.md`
</output>
